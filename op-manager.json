{"language":"Solidity","sources":{"contracts/src/OpenRankManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract OpenRankManager {\n    error ComputeRequestNotFound();\n    error ComputeResultAlreadySubmitted();\n    error ComputeResultNotFound();\n    error ChallengeNotFound();\n    error ChallengePeriodExpired();\n    error JobAlreadyFinalized();\n    error CannotFinalizeJob();\n    error InvalidFee();\n    error InvalidStake();\n    error CallerNotWhitelisted();\n\n    struct ComputeRequest {\n        address user;\n        uint256 id;\n        bytes32 trustId;\n        bytes32 seedId;\n        uint256 timestamp;\n    }\n\n    struct ComputeResult {\n        address computer;\n        uint256 computeId;\n        bytes32 commitment;\n        bytes32 scoresId;\n        uint256 timestamp;\n    }\n\n    struct Challenge {\n        address challenger;\n        uint256 timestamp;\n    }\n\n    uint256 constant CHALLENGE_WINDOW = 60;\n    uint256 constant RXP_WINDOW = 60;\n    uint256 public constant FEE = 100;\n    uint256 public constant STAKE = 100;\n\n    uint256 public idCounter;\n    mapping(address => bool) whitelistedComputers;\n    mapping(address => bool) whitelistedChallengers;\n    mapping(address => bool) whitelistedUsers;\n    mapping(uint256 => ComputeRequest) computeRequests;\n    mapping(uint256 => ComputeResult) computeResults;\n    mapping(uint256 => Challenge) challenges;\n    mapping(uint256 => bool) finalizedJobs;\n\n    event ComputeRequestEvent(\n        uint256 indexed computeId,\n        bytes32 trust_id,\n        bytes32 seed_id\n    );\n    event ComputeResultEvent(\n        uint256 indexed computeId,\n        bytes32 commitment,\n        bytes32 scores_id\n    );\n    event ChallengeEvent(uint256 indexed computeId);\n    event JobFinalized(uint256 indexed computeId);\n\n    constructor(\n        address[] memory computers,\n        address[] memory challengers,\n        address[] memory users\n    ) {\n        idCounter = 1;\n\n        for (uint256 i = 0; i < computers.length; i++) {\n            whitelistedComputers[computers[i]] = true;\n        }\n\n        for (uint256 i = 0; i < challengers.length; i++) {\n            whitelistedChallengers[challengers[i]] = true;\n        }\n\n        for (uint256 i = 0; i < users.length; i++) {\n            whitelistedUsers[users[i]] = true;\n        }\n    }\n\n    function submitComputeRequest(\n        bytes32 trustId,\n        bytes32 seedId\n    ) external payable returns (uint256 computeId) {\n        if (!whitelistedUsers[msg.sender]) {\n            revert CallerNotWhitelisted();\n        }\n        if (msg.value != FEE) {\n            revert InvalidFee();\n        }\n        ComputeRequest memory computeRequest = ComputeRequest({\n            user: msg.sender,\n            id: idCounter,\n            trustId: trustId,\n            seedId: seedId,\n            timestamp: block.timestamp\n        });\n        computeRequests[idCounter] = computeRequest;\n\n        emit ComputeRequestEvent(idCounter, trustId, seedId);\n\n        computeId = idCounter;\n        idCounter += 1;\n    }\n\n    function submitComputeResult(\n        uint256 computeId,\n        bytes32 commitment,\n        bytes32 scoresId\n    ) external payable returns (bool) {\n        if (!whitelistedComputers[msg.sender]) {\n            revert CallerNotWhitelisted();\n        }\n        if (computeRequests[computeId].id == 0) {\n            revert ComputeRequestNotFound();\n        }\n        if (computeResults[computeId].computeId != 0) {\n            revert ComputeResultAlreadySubmitted();\n        }\n        if (msg.value != STAKE) {\n            revert InvalidStake();\n        }\n\n        ComputeResult memory computeResult = ComputeResult({\n            computer: payable(msg.sender),\n            computeId: computeId,\n            commitment: commitment,\n            scoresId: scoresId,\n            timestamp: block.timestamp\n        });\n        computeResults[computeId] = computeResult;\n\n        emit ComputeResultEvent(computeId, commitment, scoresId);\n\n        return true;\n    }\n\n    function submitChallenge(\n        uint256 computeId\n    ) external payable returns (bool) {\n        if (!whitelistedChallengers[msg.sender]) {\n            revert CallerNotWhitelisted();\n        }\n        if (computeRequests[computeId].id == 0) {\n            revert ComputeRequestNotFound();\n        }\n        if (computeResults[computeId].computeId == 0) {\n            revert ComputeResultNotFound();\n        }\n\n        uint256 computeDiff = block.timestamp -\n            computeResults[computeId].timestamp;\n        if (computeDiff > CHALLENGE_WINDOW) {\n            revert ChallengePeriodExpired();\n        } else {\n            Challenge memory challenge = Challenge({\n                challenger: payable(msg.sender),\n                timestamp: block.timestamp\n            });\n            challenges[computeId] = challenge;\n\n            payable(challenge.challenger).transfer(FEE + STAKE);\n            finalizedJobs[computeId] = true;\n\n            emit ChallengeEvent(computeId);\n            emit JobFinalized(computeId);\n            return true;\n        }\n    }\n\n    function finalizeJob(uint256 computeId) external returns (bool) {\n        if (finalizedJobs[computeId]) {\n            revert JobAlreadyFinalized();\n        }\n        if (computeResults[computeId].computeId == 0) {\n            revert ComputeResultNotFound();\n        }\n\n        uint256 computeDiff = block.timestamp -\n            computeResults[computeId].timestamp;\n        if (\n            computeDiff > CHALLENGE_WINDOW &&\n            challenges[computeId].challenger == address(0x0)\n        ) {\n            payable(computeResults[computeId].computer).transfer(FEE + STAKE);\n            finalizedJobs[computeId] = true;\n\n            emit JobFinalized(computeId);\n\n            return true;\n        } else {\n            revert CannotFinalizeJob();\n        }\n    }\n}\n"}},"settings":{"remappings":["forge-std/=contracts/lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
